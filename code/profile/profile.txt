Thu 17 Nov 2022 01:51:25 PM EST
 > params.get_n_all: 10
 > system.run_n: 10
  None   None   None   None   None   None   None   None   None   None 
Wrote profile results to test.py.lprof
Timer unit: 1 s

Total time: 1.66989 s
File: /home/jesse/science/proj/esw/code/model/foi.py
Function: get_beta at line 14

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    14                                           @profile
    15                                           def get_beta(P,t):
    16                                             # return.shape = (a:2, p:4, s:2, i:4, s':2, i':4, h':6, c':5)
    17      8200          0.8      0.0     48.9    RbA_condom = linear_comb(P['PF_condom_t'](t) * P['RPF_condom_a'], P['Rbeta_condom'], 1)
    18      8200          0.3      0.0     17.0    RbA_circum = linear_comb(P['PF_circum_t'](t), P['Rbeta_circum'], 1)
    19      8200          0.2      0.0     13.7    P_gud_t = P['P_gud_t'](t) * P['P_gud']
    20      8200          0.1      0.0      3.2    Rbeta_gud_sus = linear_comb(P_gud_t,P['Rbeta_gud_sus'],1).reshape([1,1,2,4,1,1,1,1])
    21      8200          0.0      0.0      2.6    Rbeta_gud_inf = linear_comb(P_gud_t,P['Rbeta_gud_inf'],1).reshape([1,1,1,1,2,4,1,1])
    22      8200          0.2      0.0     14.6    return P['beta_a'] * Rbeta_gud_sus * Rbeta_gud_inf * RbA_condom * RbA_circum
    23                                             # TODO: maybe just cap beta ~<= .2 ???

Total time: 1.76831 s
File: /home/jesse/science/proj/esw/code/model/foi.py
Function: get_mix at line 25

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    25                                           @deco.nowarn
    26                                           @profile
    27                                           def get_mix(XC,P):
    28                                             # return.shape = (p:4, s:2, i:4, s':2, i':4)
    29      8200          0.2      0.0     11.7    M0 = XC[:,0,:,_] * XC[:,1,_,:] / XC.sum(axis=2).mean(axis=1)[:,_,_] + tol/10
    30      8200          0.0      0.0      1.5    m1 = M0.sum(axis=1)
    31      8200          0.0      0.0      1.0    m2 = M0.sum(axis=2)
    32                                             # print(m1 / XC[:,1,:]) # DEBUG == 1, unless XC unbalanced
    33                                             # print(m2 / XC[:,0,:]) # DEBUG == 1, unless XC unbalanced
    34      8200          0.0      0.0      0.9    M = M0 * np.exp(P['pref_pii'])
    35    101099          0.0      0.0      2.0    for k in range(100):
    36    101099          0.3      0.0     16.7      r1 = m1 / M.sum(axis=1)
    37    101099          0.2      0.0     10.5      M *= r1[:,_,:]
    38    101099          0.3      0.0     15.2      r2 = m2 / M.sum(axis=2)
    39    101099          0.2      0.0      9.8      M *= r2[:,:,_]
    40    101099          0.5      0.0     27.0      if (abs(r1-1) < tol).all() and (abs(r2-1) < tol).all():
    41      8200          0.0      0.0      0.2        break
    42      8200          0.0      0.0      1.6    M[abs(M)<tol] = 0
    43      8200          0.0      0.0      0.8    P['mix'][:,0,:,1,:] = M
    44      8200          0.0      0.0      0.9    P['mix'][:,1,:,0,:] = M.swapaxes(1,2)
    45                                             # n.b. returning on population-level scale
    46      8200          0.0      0.0      0.2    return P['mix']

Total time: 5.10499 s
File: /home/jesse/science/proj/esw/code/model/foi.py
Function: get_apply_inc at line 48

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    48                                           @deco.nowarn
    49                                           @profile
    50                                           def get_apply_inc(dX,X,t,P):
    51                                             # return.shape = (p:4, s:2, i:4, s':2, i':4)
    52                                             # NOTE: if foi_mode in ['lin','base','bpd','bpy']: return absolute infections
    53                                             #       if foi_mode in [TODO]: return *probability* of infection (aggr must be deferred)
    54                                             # define partner numbers (C) / rates (Q) for mixing, + total acts (A) for binomial models
    55      8200          0.0      0.0      0.1    if P['foi_mode'] in ['base']:
    56      8200          0.0      0.0      0.6      C_psik = P['C_psi'] - P['aC_pk']
    57                                             elif P['foi_mode'] in ['lin']:
    58                                               C_psik = P['C_psi']
    59                                               A_ap = P['F_ap']
    60                                             elif P['foi_mode'] in ['bpy']:
    61                                               dur_p_1 = np.minimum(P['dur_p'],1)
    62                                               C_psik = P['C_psi'] / dur_p_1[:,_,_,_]
    63                                               A_ap = P['F_ap'] * dur_p_1[_,:]
    64                                             elif P['foi_mode'] in ['bpd']:
    65                                               C_psik = P['C_psi'] / P['dur_p'][:,_,_,_]
    66                                               A_ap = P['F_ap'] * P['dur_p'][_,:]
    67                                             # compute the mixing
    68      8200          0.1      0.0      2.6    XC = (X[_,:,:,:,:,:] * C_psik[:,:,:,:,_,_]).sum(axis=3)
    69      8200          0.0      0.0      0.6    XC[XC<0] = 0 # TODO: double check this is safe
    70      8200          0.0      0.0      0.6    SXC = XC.sum(axis=(3,4))  # shape = (p:4, s:2, i:4)
    71      8200          0.0      0.0      0.9    PXC_hc = XC / (SXC[:,:,:,_,_] + tol/10) # shape = (p:4, s:2, i:4, h:6, c:5)
    72      8200          2.1      0.0     40.8    mix = get_mix(SXC,P) * PXC_hc[:,:,:,0,0,_,_] * P['mix_mask']
    73                                             # compute per-act probability
    74      8200          1.7      0.0     33.5    beta = get_beta(P,t) # shape: (a:2, p:4, s:2, i:4, s':2, i':4, h':6, c':5)
    75                                             # force of infection: linear vs binomial
    76      8200          0.0      0.0      0.1    if P['foi_mode'] in ['lin','base']:
    77      8200          0.2      0.0      3.8      Fbeta = np.sum(beta * P['F_ap'][:,:,_,_,_,_,_,_], axis=0)
    78      8200          0.1      0.0      2.2      inc = Fbeta * mix[:,:,:,:,:,_,_] * PXC_hc[:,_,_,:,:,:,:] # absolute infections
    79                                             elif P['foi_mode'] in ['bpd','bpy']:
    80                                               B_p = 1 - np.prod((1 - beta) ** A_ap[:,:,_,_,_,_,_,_], axis=0)
    81                                               inc = np.sum(B_p * PXC_hc[:,_,_,:,:,:,:], axis=(5,6)) * mix # absolute infections
    82                                             # aggregating & applying to dX
    83      8200          0.0      0.0      0.1    if P['foi_mode'] in ['base']:
    84      8200          0.0      0.0      0.9      dXi = inc.sum(axis=(3,4,5,6)) # acquisition: (p:4, s:2, i:4)
    85      8200          0.0      0.0      1.0      dX[:,:,0 ,0,0] -= dXi.sum(axis=0)
    86      8200          0.2      0.0      3.0      dX[:,:,1:,1,0] += np.moveaxis(dXi,0,2)
    87      8200          0.0      0.0      1.0      dXi = inc.sum(axis=(1,2)) # transmission: (p:4, s':2, i':4, h':6, c':5)
    88      8200          0.1      0.0      1.1      dX[:,:,0 ,:,:] -= dXi.sum(axis=0)
    89      8200          0.1      0.0      2.6      dX[:,:,1:,:,:] += np.moveaxis(dXi,0,2)
    90      8200          0.0      0.0      0.9      dXi = X[:,:,1:,:,:] / P['dur_p'][_,_,:,_,_] # new partnerships: (s:2, i:4, k:4, h:6, c:5)
    91      8200          0.0      0.0      0.7      dX[:,:,1:,:,:] -= dXi
    92      8200          0.1      0.0      1.2      dX[:,:,0 ,:,:] += dXi.sum(axis=2)
    93      8200          0.1      0.0      1.6      return inc.sum(axis=(5,6))
    94                                             # all other models don't use dimension "k" in X
    95                                             elif P['foi_mode'] in ['lin']:
    96                                               inc = inc.sum(axis=(5,6))
    97                                               dXi = aggr_inc(inc,P['foi_mode'],axis=(0,3,4))
    98                                             elif P['foi_mode'] in ['bpd','bpy']:
    99                                               dXi = aggr_inc(inc,P['foi_mode'],axis=(0,3,4))
   100                                             dX[:,:,0,0,0] -= dXi
   101                                             dX[:,:,0,1,0] += dXi
   102                                             return inc

Total time: 0 s
File: /home/jesse/science/proj/esw/code/model/foi.py
Function: aggr_inc at line 104

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   104                                           @profile
   105                                           def aggr_inc(inc,foi_mode,axis,Xsus=1.,keepdims=False):
   106                                             # TODO:
   107                                             # returns absolute infections after appropriately aggregating "inc"
   108                                             # Xsus only needed if 'foi_mode' in ['bmy']
   109                                             if foi_mode in ['lin','base','bpy','bpd']:
   110                                               return inc.sum(axis=axis,keepdims=keepdims)
   111                                             if foi_mode in []: # TODO
   112                                               return (1 - np.prod(1 - inc,axis=axis,keepdims=keepdims)) * Xsus

Total time: 8.61285 s
File: /home/jesse/science/proj/esw/code/model/system.py
Function: get_dX at line 71

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    71                                           @profile
    72                                           def get_dX(X,t,P):
    73                                             # initialize
    74      8200          0.0      0.0      0.2    dX = 0*X # (s:2, i:4, k:4, h:6, c:5)
    75                                             # force of infection
    76      8200          5.3      0.0     61.9    inc = foi.get_apply_inc(dX,X,t,P) # (p:4, s:2, i:4, s':2, i':4)
    77                                             # HIV transitions
    78      8200          0.0      0.0      0.5    dXi = X[:,:,:,1:5,0:3] * P['prog_h'] # all hiv & untreated
    79      8200          0.0      0.0      0.5    dX[:,:,:,1:5,0:3] -= dXi
    80      8200          0.0      0.0      0.4    dX[:,:,:,2:6,0:3] += dXi
    81                                             # CD4 recovery
    82      8200          0.0      0.0      0.4    dXi = X[:,:,:,3:6,3:5] * P['unprog_h'] # low CD4 & treated
    83      8200          0.0      0.0      0.4    dX[:,:,:,3:6,3:5] -= dXi
    84      8200          0.0      0.0      0.4    dX[:,:,:,2:5,3:5] += dXi
    85                                             # births & deaths
    86      8200          0.4      0.0      4.1    dX[:,:,0,0,0] += X.sum() * P['PX_si'] * P['birth_t'](t)
    87      8200          0.0      0.0      0.4    dX -= X * P['death']
    88      8200          0.0      0.0      0.4    dX -= X * P['death_hc']
    89                                             # turnover
    90      8200          0.5      0.0      5.8    dXi = get_turnover(P,X)
    91      8200          0.1      0.0      0.7    dX -= dXi.sum(axis=2) # (s:2, i:4, k:5, h:6, c:5)
    92      8200          0.0      0.0      0.5    dX += dXi.sum(axis=1) # (s:2, i':4, k:5, h:6, c:5)
    93                                             # cascade: diagnosis
    94      8200          0.3      0.0      3.7    dXi = X[:,:,:,1:6,0] * P['dx_t'](t) * P['Rdx_si'] * P['Rdx_scen']
    95      8200          0.0      0.0      0.4    dX[:,:,:,1:6,0] -= dXi # undiag
    96      8200          0.0      0.0      0.3    dX[:,:,:,1:6,1] += dXi # diag
    97                                             # cascade: treatment
    98      8200          1.1      0.0     12.9    dXi = X[:,:,:,1:6,1] * P['tx_t'](t) * P['Rtx_ht'](t) * P['Rtx_si'] * P['Rtx_scen']
    99      8200          0.0      0.0      0.4    dX[:,:,:,1:6,1] -= dXi # diag
   100      8200          0.0      0.0      0.3    dX[:,:,:,1:6,3] += dXi # treat
   101                                             # cascade: VLS
   102      8200          0.0      0.0      0.3    dXi = X[:,:,:,1:6,3] * P['vx']
   103      8200          0.0      0.0      0.3    dX[:,:,:,1:6,3] -= dXi # treat
   104      8200          0.0      0.0      0.3    dX[:,:,:,1:6,4] += dXi # vls
   105                                             # cascade: unlink
   106      8200          0.3      0.0      3.0    dXi = X[:,:,:,1:6,4] * P['unvx_t'](t) * P['Rux_scen']
   107      8200          0.0      0.0      0.3    dX[:,:,:,1:6,4] -= dXi # vls
   108      8200          0.0      0.0      0.3    dX[:,:,:,1:6,2] += dXi # unlink
   109                                             # cascade: relink
   110      8200          0.0      0.0      0.3    dXi = X[:,:,:,1:6,2] * P['retx']
   111      8200          0.0      0.0      0.3    dX[:,:,:,1:6,2] -= dXi # unlink
   112      8200          0.0      0.0      0.3    dX[:,:,:,1:6,4] += dXi # vls
   113      8200          0.0      0.0      0.0    return {
   114      8200          0.0      0.0      0.0      'dX': dX,
   115      8200          0.0      0.0      0.0      'inc': inc,
   116                                             }

Total time: 0.378725 s
File: /home/jesse/science/proj/esw/code/model/system.py
Function: get_turnover at line 118

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   118                                           @deco.nowarn
   119                                           @profile
   120                                           def get_turnover(P,X):
   121                                             # return.shape = (s:2, i:4, i':4, k:5, h:6, c:5)
   122      8200          0.1      0.0     16.6    turn = P['turn_sii'][:,:,:,_,_,_] * X[:,:,_,:,:,:]
   123                                             # P['ORturn_sus:hiv'] = 0 # DEBUG
   124      8200          0.1      0.0     22.6    if np.any(X[:,:,:,1:,:]): # HIV introduced
   125      6160          0.0      0.0      8.0      Xhiv = X[:,:,:,1:,:].sum(axis=(2,3,4))
   126                                               # odds of turnover aomng sus vs hiv (source-group-specific)
   127      6160          0.0      0.0      9.2      Osus = P['ORturn_sus:hiv'] * nan_to_value(X[:,:,0,0,0] / Xhiv, 1)[:,:,_]
   128      6160          0.0      0.0     10.2      Phc_hiv = nan_to_value(X[:,:,:,1:,:] / Xhiv[:,:,_,_,_], 0)
   129      6160          0.1      0.0     13.7      turn_hiv = turn.sum(axis=(3,4,5)) / (1 + Osus)
   130      6160          0.1      0.0     14.8      turn[:,:,:,:,1:,:] = turn_hiv[:,:,:,_,_,_] * Phc_hiv[:,:,_,:,:,:]
   131      6160          0.0      0.0      4.2      turn[:,:,:,0,0,0]  = turn_hiv * Osus
   132      8200          0.0      0.0      0.6    return turn

